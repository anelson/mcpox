use std::ops::Deref;
use std::sync::Arc;

use tokio_util::sync::{CancellationToken, DropGuard};

use crate::{Result, handler, router, service, service_connection, transport};

pub struct ClientBuilder<Stage> {
    stage: Stage,
}

impl Default for ClientBuilder<Stage1> {
    fn default() -> Self {
        Self { stage: Stage1 }
    }
}

impl ClientBuilder<Stage1> {
    pub fn with_state<S: Clone + Send + Sync + 'static>(self, state: S) -> ClientBuilder<Stage2<S>> {
        ClientBuilder {
            stage: Stage2 {
                router: router::Router::new_with_state(state),
            },
        }
    }

    pub fn without_state(self) -> ClientBuilder<Stage2<()>> {
        ClientBuilder {
            stage: Stage2 {
                router: router::Router::new_stateless(),
            },
        }
    }

    pub fn with_router<S: Clone + Send + Sync + 'static>(
        self,
        router: router::Router<S>,
    ) -> ClientBuilder<Stage2<S>> {
        ClientBuilder {
            stage: Stage2 { router },
        }
    }

    /// Skip registering any handlers or state or routers and make a client bound to this tranport
    pub fn bind(self, transport: impl transport::Transport) -> Result<Client<()>> {
        self.without_state().bind(transport)
    }
}

impl<S: Clone + Send + Sync + 'static> ClientBuilder<Stage2<S>> {
    pub fn with_fallback_handler<H, HackT>(mut self, handler: H) -> Self
    where
        H: handler::Handler<HackT, S> + 'static,
        HackT: Send + Sync + 'static,
    {
        self.stage.router.register_fallback_handler(handler);
        self
    }

    pub fn with_handler<H, HackT>(mut self, method: impl Into<String>, handler: H) -> Self
    where
        H: handler::Handler<HackT, S> + 'static,
        HackT: Send + Sync + 'static,
    {
        self.stage.router.register_handler(method, handler);
        self
    }

    pub fn bind(self, transport: impl transport::Transport) -> Result<Client<S>> {
        Client::bind(transport, self.stage.router)
    }
}

#[doc(hidden)]
pub struct Stage1;

#[doc(hidden)]
pub struct Stage2<S: Clone + Send + Sync + 'static> {
    router: router::Router<S>,
}

pub struct Client<S = ()> {
    state: S,
    connection_handle: service_connection::ServiceConnectionHandle,
    drop_guard: Arc<DropGuard>,
}

impl<S: Clone> Clone for Client<S> {
    fn clone(&self) -> Self {
        Self {
            state: self.state.clone(),
            connection_handle: self.connection_handle.clone(),
            drop_guard: self.drop_guard.clone(),
        }
    }
}

impl Client {
    pub fn builder() -> ClientBuilder<Stage1> {
        ClientBuilder::default()
    }
}

impl<S: Clone + Send + Sync + 'static> Client<S> {
    /// Create a new client, bound to a transport and a router.
    ///
    /// This will start an async task which handles incoming messages from the transport, and also
    /// sends outgoing messages generated by this client.
    fn bind(transport: impl transport::Transport, router: router::Router<S>) -> Result<Self> {
        let cancellation_token = CancellationToken::new();
        let drop_guard = cancellation_token.clone().drop_guard();

        // Create a Service whose lifetime is bounded by this cancellation token that we control.
        // This is necessary because we will drop the service once we've spawned a connection
        // handler, and we don't want the service to auto-terminate its connection handlers in that
        // case.
        let state = router.state().clone();
        let service = service::Service::new_cancellable(cancellation_token, router);

        let span = tracing::info_span!("client");
        let _guard = span.enter();

        let (future, handle) = service.service_connection(transport::Peer::new(transport))?;

        // TODO: In the future perhaps provide more flexbility in how the future gets spawned
        tokio::spawn(future);
        Ok(Client {
            state,
            connection_handle: handle,
            drop_guard: Arc::new(drop_guard),
        })
    }

    /// The shared state of the client, which is also accessible to any handlers registered on the
    /// client.
    pub fn state(&self) -> &S {
        &self.state
    }
}

/// Deref Client automatically to [`service_connection::ServiceConnectionHandle`] so that its
/// methods for calling and raising notifications can be used
impl<S: Clone + Send + Sync + 'static> Deref for Client<S> {
    type Target = service_connection::ServiceConnectionHandle;

    fn deref(&self) -> &Self::Target {
        &self.connection_handle
    }
}
