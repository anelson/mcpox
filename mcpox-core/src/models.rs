//! Types that correspond to entries in the MCP Typescript reference schema.
//!
//! See <https://github.com/modelcontextprotocol/modelcontextprotocol/blob/main/schema/2025-03-26/schema.ts>
//! for the full schema.
//!
//! Note that Rust is a substantially different language than Typescript, leading to a very
//! different implementation of both JSON-RPC and the MCP layer on top.  Many of these types are written by
//! hand with reference to the spec, while others are generated by `typify` using the JSON Schema
//! spec file as input.
//!
//! An earlier implementation used the `typify` crate to generate all of the Rust types from the official
//! MCP JSON Schema file, but that became unwieldy due to the
//! separation of JSON RPC from MCP in this implementation, as well as the less laisse faire attitude
//! towards inheritance in Rust.

/// The types that are machine-generated using `typify` from the MCP JSON Schema file.
#[allow(
    dead_code,
    irrefutable_let_patterns,
    clippy::derivable_impls,
    clippy::clone_on_copy,
    rustdoc::bare_urls
)]
mod typify_generated {
    include!(concat!(env!("OUT_DIR"), "/typify_generated.rs"));
}

// Re-export the typify types that are actually used in our implementation
pub use typify_generated::{
    ClientCapabilities, Implementation, InitializeRequestParams as InitializeRequest, InitializeResult,
    ListResourcesRequestParams as ListResourcesRequest, ListResourcesResult,
    ListToolsRequestParams as ListToolsRequest, ListToolsResult, ServerCapabilities,
};

/// Methods defined by the MCP spec and their corresponding string representations.
///
/// Using an enum for this, combined with the `strum` crate, gives us a type-safe way to represent
/// the set of possible methods without the hassle and clunky ergonomics of a newtype pattern.
#[derive(Clone, Debug, strum::Display)]
pub enum Methods {
    /// Methods that the server is expected to implement and that the client can call
    Server(ServerMethods),

    /// Methods that the client is expected to implement and that the server can call
    Client(ClientMethods),
}

/// See [`Methods`] for more details.
#[derive(Clone, Debug, strum::Display, strum::IntoStaticStr, strum::EnumIter)]
#[strum(serialize_all = "camelCase")]
pub enum ServerMethods {
    Ping,
    Initialize,
    #[strum(serialize = "completion/complete")]
    Complete,
    #[strum(serialize = "logging/setLevel")]
    SetLevel,
    #[strum(serialize = "prompts/get")]
    GetPrompt,
    #[strum(serialize = "prompts/list")]
    ListPrompts,
    #[strum(serialize = "resources/list")]
    ListResources,
    #[strum(serialize = "resources/templates/list")]
    ListResourceTemplates,
    #[strum(serialize = "resources/read")]
    ReadResource,
    #[strum(serialize = "resources/subscribe")]
    Subscribe,
    /// TODO: This isn't in the published spec text but it's in the Typescript schema.
    #[strum(serialize = "resources/unsubscribe")]
    Unsubscribe,
    #[strum(serialize = "tools/call")]
    CallTool,
    #[strum(serialize = "tools/list")]
    ListTools,
}

/// See [`Methods`] for more details.
#[derive(Clone, Debug, strum::Display, strum::IntoStaticStr, strum::EnumIter)]
#[strum(serialize_all = "camelCase")]
pub enum ClientMethods {
    Ping,
    #[strum(serialize = "sampling/createMessage")]
    CreateMessage,
    #[strum(serialize = "roots/list")]
    ListRoots,
}

/// Notifications defined by the MCP spec and their corresponding string representations.
///
/// Using an enum for this, combined with the `strum` crate, gives us a type-safe way to represent
/// the set of possible notifications without the hassle and clunky ergonomics of a newtype pattern.
#[derive(Clone, Debug, strum::Display)]
pub enum Notifications {
    /// Notifications that the server is expected to implement and that the client can call
    Server(ServerNotifications),

    /// Notifications that the client is expected to implement and that the server can call
    Client(ClientNotifications),
}

/// Notifications that the server can generate and send to the client.  In other words,
/// notifications from the server that the client should be able to handle
#[derive(Clone, Debug, strum::Display, strum::IntoStaticStr, strum::EnumIter)]
pub enum ServerNotifications {
    #[strum(serialize = "notifications/cancelled")]
    Cancelled,
    #[strum(serialize = "notifications/progress")]
    Progress,
    #[strum(serialize = "notifications/message")]
    LoggingMessage,
    #[strum(serialize = "notifications/resources/updated")]
    ResourceUpdated,
    #[strum(serialize = "notifications/resources/list_changed")]
    ResourceListChanged,
    #[strum(serialize = "notifications/tools/list_changed")]
    ToolListChanged,
    #[strum(serialize = "notifications/prompts/list_changed")]
    PromptListChanged,
}

/// Notifications that the client can generate and send to the server.  In other words,
/// notifications from the client that the server should be able to handle
#[derive(Clone, Debug, strum::Display, strum::IntoStaticStr, strum::EnumIter)]
pub enum ClientNotifications {
    #[strum(serialize = "notifications/cancelled")]
    Cancelled,
    #[strum(serialize = "notifications/progress")]
    Progress,
    #[strum(serialize = "notifications/initialized")]
    Initialized,
    #[strum(serialize = "notifications/roots/list_changed")]
    RootsListChanged,
}
